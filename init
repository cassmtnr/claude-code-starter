#!/usr/bin/env bash
#
# Claude Code Starter - Init Script
#

set -e

VERSION="0.0.2"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m'

# Default options
FORCE=false

# Get framework directory (resolve symlinks for npm global install)
SCRIPT_PATH="$0"
if [ -L "$SCRIPT_PATH" ]; then
    # Resolve symlink
    if command -v readlink >/dev/null 2>&1; then
        SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
        # Handle relative symlinks
        if [[ "$SCRIPT_PATH" != /* ]]; then
            SCRIPT_PATH="$(dirname "$0")/$SCRIPT_PATH"
        fi
    fi
fi
FRAMEWORK_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Help message
show_help() {
    cat << EOF
Claude Code Starter v${VERSION}

A lightweight starter kit for AI-assisted development with Claude Code.

USAGE:
    npx claude-code-starter [OPTIONS]
    claude-code-starter [OPTIONS]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version number
    -f, --force     Force overwrite of CLAUDE.md and settings.json

EXAMPLES:
    # Initialize in current directory (no install required)
    cd /path/to/your-project
    npx claude-code-starter

    # Force overwrite existing files
    npx claude-code-starter --force

    # If installed globally
    claude-code-starter

WHAT IT DOES:
    1. Creates .claude/ directory structure
    2. Copies CLAUDE.md (instructions for Claude)
    3. Sets up slash commands (/task, /status, /done, /analyze)
    4. Installs skill files for patterns, debugging, testing
    5. Creates initial task state

MORE INFO:
    https://github.com/cassianomon/claude-code-starter
EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "claude-code-starter v${VERSION}"
            exit 0
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Get project directory (current working directory)
PROJECT_DIR="$(pwd)"

# Prevent running init inside the framework folder itself
if [ "$PROJECT_DIR" = "$FRAMEWORK_DIR" ]; then
    echo -e "${YELLOW}Run this from your project directory, not the framework folder.${NC}"
    echo ""
    echo "Usage:"
    echo "  cd /path/to/your-project"
    echo "  npx claude-code-starter"
    exit 1
fi

# Validate framework files exist
validate_framework() {
    local missing=()

    [ ! -f "$FRAMEWORK_DIR/CLAUDE.md" ] && missing+=("CLAUDE.md")
    [ ! -f "$FRAMEWORK_DIR/.claude/settings.json" ] && missing+=(".claude/settings.json")
    [ ! -d "$FRAMEWORK_DIR/.claude/commands" ] && missing+=(".claude/commands/")
    [ ! -d "$FRAMEWORK_DIR/.claude/skills" ] && missing+=(".claude/skills/")

    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}Error: Framework files missing:${NC}"
        for file in "${missing[@]}"; do
            echo "  - $file"
        done
        echo ""
        echo "The framework installation appears to be incomplete."
        echo "Try reinstalling: npm install -g claude-code-starter"
        exit 1
    fi
}

validate_framework

# Show banner
echo -e "${CYAN}╔═════════════════════════════════════╗${NC}"
echo -e "${CYAN}║   Claude Code Starter v${VERSION}        ║${NC}"
echo -e "${CYAN}╚═════════════════════════════════════╝${NC}"
echo ""

# Create .claude directory structure
mkdir -p "$PROJECT_DIR/.claude/state"
mkdir -p "$PROJECT_DIR/.claude/commands"
mkdir -p "$PROJECT_DIR/.claude/skills"

# Copy framework files to project
echo -e "${BLUE}Setting up framework files...${NC}"

# Copy CLAUDE.md
if [ ! -f "$PROJECT_DIR/CLAUDE.md" ] || [ "$FORCE" = true ]; then
    cp -- "$FRAMEWORK_DIR/CLAUDE.md" "$PROJECT_DIR/CLAUDE.md"
    if [ "$FORCE" = true ] && [ -f "$PROJECT_DIR/CLAUDE.md" ]; then
        echo "  Updated CLAUDE.md (forced)"
    else
        echo "  Created CLAUDE.md"
    fi
else
    echo "  CLAUDE.md exists (use --force to overwrite)"
fi

# Copy settings.json
if [ ! -f "$PROJECT_DIR/.claude/settings.json" ] || [ "$FORCE" = true ]; then
    cp -- "$FRAMEWORK_DIR/.claude/settings.json" "$PROJECT_DIR/.claude/settings.json"
    if [ "$FORCE" = true ] && [ -f "$PROJECT_DIR/.claude/settings.json" ]; then
        echo "  Updated .claude/settings.json (forced)"
    else
        echo "  Created .claude/settings.json"
    fi
else
    echo "  settings.json exists (use --force to overwrite)"
fi

# Copy commands (always update - these are framework-managed)
cp -r -- "$FRAMEWORK_DIR/.claude/commands/"* "$PROJECT_DIR/.claude/commands/"
echo "  Updated .claude/commands/"

# Copy skills (always update - these are framework-managed)
cp -r -- "$FRAMEWORK_DIR/.claude/skills/"* "$PROJECT_DIR/.claude/skills/"
echo "  Updated .claude/skills/"

# Write version file
echo "$VERSION" > "$PROJECT_DIR/.claude/.version"

echo ""

# Detect project type (bash 3.x compatible - no mapfile)
detect_project() {
    local has_code=false
    local tech_stack=""

    # Check for various project indicators
    [ -f "$PROJECT_DIR/package.json" ] && tech_stack+="Node.js " && has_code=true
    [ -f "$PROJECT_DIR/tsconfig.json" ] && tech_stack+="TypeScript " && has_code=true
    [ -f "$PROJECT_DIR/requirements.txt" ] && tech_stack+="Python " && has_code=true
    [ -f "$PROJECT_DIR/pyproject.toml" ] && tech_stack+="Python " && has_code=true
    [ -f "$PROJECT_DIR/Cargo.toml" ] && tech_stack+="Rust " && has_code=true
    [ -f "$PROJECT_DIR/go.mod" ] && tech_stack+="Go " && has_code=true
    [ -f "$PROJECT_DIR/pom.xml" ] && tech_stack+="Java " && has_code=true
    [ -f "$PROJECT_DIR/build.gradle" ] && tech_stack+="Java/Kotlin " && has_code=true
    [ -f "$PROJECT_DIR/Gemfile" ] && tech_stack+="Ruby " && has_code=true
    [ -d "$PROJECT_DIR/src" ] && has_code=true
    [ -d "$PROJECT_DIR/lib" ] && has_code=true
    [ -d "$PROJECT_DIR/app" ] && has_code=true

    # Check for source files (optimized with -prune)
    if [ "$has_code" = false ]; then
        local file_count
        file_count=$(find "$PROJECT_DIR" -maxdepth 3 \
            \( -name "node_modules" -o -name ".git" -o -name "dist" -o -name "build" \) -prune -o \
            \( -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.rb" \) -print 2>/dev/null | head -20 | wc -l | tr -d ' ')
        [ "$file_count" -gt 0 ] && has_code=true
    fi

    # Return values via global variables (bash 3.x compatible)
    PROJECT_TYPE="new"
    TECH_STACK=""
    if [ "$has_code" = true ]; then
        PROJECT_TYPE="existing"
        TECH_STACK="$tech_stack"
    fi
}

# Run detection
detect_project

if [ "$PROJECT_TYPE" = "existing" ]; then
    echo -e "${GREEN}Detected existing project${NC}"
    [ -n "$TECH_STACK" ] && echo -e "Tech stack: ${CYAN}$TECH_STACK${NC}"
    echo ""

    # Run analysis
    echo -e "${BLUE}Analyzing codebase...${NC}"

    # Count files (optimized with -prune)
    total_files=$(find "$PROJECT_DIR" \
        \( -name "node_modules" -o -name ".git" -o -name "dist" -o -name "build" -o -name ".claude" \) -prune -o \
        -type f \( -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.py" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.rb" -o -name "*.php" \) -print 2>/dev/null | wc -l | tr -d ' ')

    # Detect key directories
    key_dirs=""
    [ -d "$PROJECT_DIR/src" ] && key_dirs+="src/ "
    [ -d "$PROJECT_DIR/lib" ] && key_dirs+="lib/ "
    [ -d "$PROJECT_DIR/app" ] && key_dirs+="app/ "
    [ -d "$PROJECT_DIR/api" ] && key_dirs+="api/ "
    [ -d "$PROJECT_DIR/components" ] && key_dirs+="components/ "
    [ -d "$PROJECT_DIR/pages" ] && key_dirs+="pages/ "
    [ -d "$PROJECT_DIR/tests" ] && key_dirs+="tests/ "
    [ -d "$PROJECT_DIR/test" ] && key_dirs+="test/ "
    [ -d "$PROJECT_DIR/__tests__" ] && key_dirs+="__tests__/ "

    # Detect frameworks
    frameworks=""
    if [ -f "$PROJECT_DIR/package.json" ]; then
        grep -q '"react"' "$PROJECT_DIR/package.json" 2>/dev/null && frameworks+="React "
        grep -q '"next"' "$PROJECT_DIR/package.json" 2>/dev/null && frameworks+="Next.js "
        grep -q '"vue"' "$PROJECT_DIR/package.json" 2>/dev/null && frameworks+="Vue "
        grep -q '"express"' "$PROJECT_DIR/package.json" 2>/dev/null && frameworks+="Express "
        grep -q '"fastify"' "$PROJECT_DIR/package.json" 2>/dev/null && frameworks+="Fastify "
        grep -q '"@nestjs"' "$PROJECT_DIR/package.json" 2>/dev/null && frameworks+="NestJS "
    fi
    if [ -f "$PROJECT_DIR/requirements.txt" ]; then
        grep -qi 'django' "$PROJECT_DIR/requirements.txt" 2>/dev/null && frameworks+="Django "
        grep -qi 'flask' "$PROJECT_DIR/requirements.txt" 2>/dev/null && frameworks+="Flask "
        grep -qi 'fastapi' "$PROJECT_DIR/requirements.txt" 2>/dev/null && frameworks+="FastAPI "
    fi

    echo ""
    echo "  Files: $total_files source files"
    [ -n "$key_dirs" ] && echo "  Directories: $key_dirs"
    [ -n "$frameworks" ] && echo "  Frameworks: $frameworks"
    echo ""

    # Only create task file if it doesn't exist (preserve existing state)
    if [ ! -f "$PROJECT_DIR/.claude/state/task.md" ]; then
        cat > "$PROJECT_DIR/.claude/state/task.md" << 'EOF'
# Current Task

## Status: Ready

No active task. Start one with `/task <description>`.

## Project Summary

This is an existing codebase. Use `/analyze` to explore specific areas.

## Quick Commands

- `/task` - Start working on something
- `/status` - See current state
- `/analyze` - Deep dive into code
- `/done` - Mark task complete
EOF
        echo "  Created .claude/state/task.md"
    else
        echo "  Task state preserved (.claude/state/task.md)"
    fi

    echo ""
    echo -e "${GREEN}Ready!${NC} Run ${CYAN}claude${NC} to start."

else
    echo -e "${YELLOW}New project detected${NC}"
    echo ""

    # Only ask for task if state doesn't exist
    if [ ! -f "$PROJECT_DIR/.claude/state/task.md" ]; then
        echo "What are you building?"
        echo -n "> "
        read -r initial_task

        # Sanitize input - remove characters that could break heredoc
        initial_task="${initial_task//\$/}"
        initial_task="${initial_task//\`/}"
        initial_task="${initial_task//\\/}"

        if [ -z "$initial_task" ]; then
            initial_task="Explore and set up project"
        fi

        # Create initial task file for new project
        cat > "$PROJECT_DIR/.claude/state/task.md" << TASKEOF
# Current Task

## Status: In Progress

**Task:** $initial_task

## Context

New project - no existing code yet.

## Next Steps

1. Define project structure
2. Set up development environment
3. Start implementation

## Decisions

(None yet - starting fresh)
TASKEOF

        echo ""
        echo -e "${GREEN}Ready!${NC} Run ${CYAN}claude${NC} to start working on: $initial_task"
    else
        echo "  Task state preserved (.claude/state/task.md)"
        echo ""
        echo -e "${GREEN}Ready!${NC} Run ${CYAN}claude${NC} to continue."
    fi
fi

echo ""
echo -e "${BLUE}Tip:${NC} Add ${CYAN}.claude/${NC} to your global .gitignore"
